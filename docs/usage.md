# Adding to your CMake project
To use the FortUTF framework, you can either use `FetchContent` to fetch the whole repository or copy the `cmake/forrtutf.cmake` file directly to your project. Then, include the `cmake/forrtutf.cmake` file within the `CMakeLists.txt` of your project.

In addition you must set either the `FORTUTF_PROJECT_SRC_FILES` variable to point to the location of the FORTRAN source files for your project, or the `FORTUTF_PROJECT_SRC_LIBRARY` variable to give the location of the library generated by building your project.

By default FortUTF will assume tests to lie within `${CMAKE_SOURCE_DIR}/tests`, you can override this by setting `FORTUTF_PROJECT_TEST_DIR` to your tests directory. FortUTF looks for add files prefixed with `test_` under the path `FORTUTF_PROJECT_TEST_DIR` to collect tests. Files that does not follow the naming convection can also be found by adding them to the `FORTUTF_PROJECT_TEST_FILES` variable.

It is recommended that compiling and running of the tests be controlled by a CMake option:

```cmake
# Project CMakeLists.txt
OPTION( BUILD_TESTS "Build Project Unit tests" OFF )

IF( BUILD_TESTS )
    # Set path to test files (optional)
    SET(FORTUTF_PROJECT_TEST_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tests)

    # Set required project files variable e.g. files in 'src' directory within the project directory
    FILE( GLOB FORTUTF_PROJECT_SRC_FILES ${CMAKE_CURRENT_SOURCE_DIR}/src/*.f90 )

    # Include the FortUTF test finding script
    SET( FORTUTF_ROOT /path/to/FortUTF/folder )
    INCLUDE( ${FORTUTF_ROOT}/cmake/fortutf.cmake )
    ...

    # Find and compile with the CMake function
    FortUTF_Find_Tests()
ENDIF()
```
The script will automatically locate any tests within the project matching the pattern `test_*.f90`, and create a new script `run_tests.f90` within the build directory which will be compiled.

# Writing Unit tests
To write unit tests create an F90 script prefixed with `test_` in a test directory and write the tests as subroutines within a modules.

The subroutine `TAG_TEST` can be called prior to the assertion to provide an identifier for recognising the test within the results should it fail, if a tag is not provided the test will be named `Test <N>` where `N` is the test number.

# Build unit tests with custom flags and external libraries
The CMake function `FortUTF_Find_Tests` contains optional arguments for adding flags and linking external libraries for the tests. The `FortUTF` library is linked automatically and does not need to be passed specifically.

```cmake
FortUTF_Find_Tests(OPTIONS <compile_options> LIBRARIES <external_libraries> MODULE_DIRS <path_to_dirs>)
```
One can add compile options (flags) after the keyword `OPTIONS`, link libraries after the keyword `LIBRARIES` and include path to module files after the keyword `MODULE_DIRS`.  
Both `<compile_options>` and `<external_libraries>` can be multiple arguments, but `<path_to_dirs>` is a single argument string to all include paths.  
An usage example is provided with the `examples/demo_project`.

# Running the Tests

The compiled test binary named in the form `<PROJECT_NAME>_Tests` can be run either with arguments which will execute all tests, or by providing the names of the tests to run:

```bash
./build/MyProject_Tests
```

```bash
./build/MyProject_Tests TEST_FOOBAR
```

### Example

#### Project source file
```fortran
! my_functions.f90

MODULE MY_MODULE
    IMPLICIT NONE
    CONTAINS

    REAL(8) FUNCTION ADDER(NUMBER_1, NUMBER_2)
        REAL(8), INTENT(IN) :: NUMBER_1, NUMBER_2
        ADDER = NUMBER_1 + NUMBER_2
    END FUNCTION

END MODULE
```

#### Test source file
```fortran
! test_adder.f90

MODULE TEST_MY_FUNCTIONS
    USE FORTUTF     ! use FortUTF to make tests
    IMPLICIT NONE
    CONTAINS

    SUBROUTINE TEST_ADDER
        USE MY_MODULE, ONLY: ADDER
        CALL TAG_TEST("TEST_ADDER_FUNCTION") ! Set a unique identifier to recognise this test
        CALL ASSERT_EQUAL(ADDER(2, 3), 5)
    END SUBROUTINE

END MODULE
```

It is recommended that the layout of your test scripts mirror that of your sources, i.e. each source file will be accompanied by a relevant test file containing a module of subroutines for checking its methods.
