MODULE FUTS_ASSERTIONS
    USE FUTS_SUITE, ONLY: TOTAL, PASSED, IDENTIFIER
    
    IMPLICIT NONE

    INTERFACE ASSERT_EQUAL
        MODULE PROCEDURE ASSERT_EQUAL_INT
        MODULE PROCEDURE ASSERT_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_EQUAL_LOGICAL
        MODULE PROCEDURE ASSERT_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_EQUAL_REAL_4BYTE
        MODULE PROCEDURE ASSERT_EQUAL_COMPLEX
        MODULE PROCEDURE ASSERT_EQUAL_CHAR
    END INTERFACE ASSERT_EQUAL

    INTERFACE ASSERT_ALMOST_EQUAL
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_INT
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_REAL_4BYTE
    END INTERFACE ASSERT_ALMOST_EQUAL

    INTERFACE ASSERT_NOT_EQUAL
        MODULE PROCEDURE ASSERT_NOT_EQUAL_INT
        MODULE PROCEDURE ASSERT_NOT_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_LOGICAL
        MODULE PROCEDURE ASSERT_NOT_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_REAL_4BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_COMPLEX
        MODULE PROCEDURE ASSERT_NOT_EQUAL_CHAR
    END INTERFACE ASSERT_NOT_EQUAL

    INTERFACE ASSERT_LESS_THAN
        MODULE PROCEDURE ASSERT_LESS_THAN_INT
        MODULE PROCEDURE ASSERT_LESS_THAN_INT_2BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_REAL_8BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_REAL_4BYTE
    END INTERFACE ASSERT_LESS_THAN

    INTERFACE ASSERT_LESS_THAN_EQUAL
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_INT
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_REAL_4BYTE
    END INTERFACE ASSERT_LESS_THAN_EQUAL

    INTERFACE ASSERT_GREATER_THAN
        MODULE PROCEDURE ASSERT_GREATER_THAN_INT
        MODULE PROCEDURE ASSERT_GREATER_THAN_INT_2BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_REAL_8BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_REAL_4BYTE
    END INTERFACE ASSERT_GREATER_THAN

    INTERFACE ASSERT_GREATER_THAN_EQUAL
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_INT
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_REAL_4BYTE
    END INTERFACE ASSERT_GREATER_THAN_EQUAL

    INTERFACE ASSERT_IS_REAL
        MODULE PROCEDURE ASSERT_IS_REAL_INT
        MODULE PROCEDURE ASSERT_IS_REAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_REAL_4BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_COMPLEX
        MODULE PROCEDURE ASSERT_IS_REAL_CHAR
        MODULE PROCEDURE ASSERT_IS_REAL_BOOL
    END INTERFACE ASSERT_IS_REAL
    
    CONTAINS

    SUBROUTINE ASSERT_EQUAL_INT(INT_1, INT_2)
        INTEGER, INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 == INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_EQUAL_INT

    SUBROUTINE ASSERT_EQUAL_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 == REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_EQUAL_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 == REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_EQUAL_COMPLEX(COMP_1, COMP_2)
        COMPLEX, INTENT(IN) :: COMP_1, COMP_2
        
        TOTAL = TOTAL+1

        IF(COMP_1 == COMP_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_EQUAL_COMPLEX

    SUBROUTINE ASSERT_EQUAL_LOGICAL(BOOL_1, BOOL_2)
        LOGICAL, INTENT(IN) :: BOOL_1, BOOL_2
        
        TOTAL = TOTAL+1

        IF(BOOL_1 .EQV. BOOL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_EQUAL_LOGICAL

    SUBROUTINE ASSERT_EQUAL_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2
        
        TOTAL = TOTAL+1

        IF(INT_1 == INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_EQUAL_CHAR(CHAR_1, CHAR_2)
        CHARACTER, INTENT(IN) :: CHAR_1, CHAR_2

        IF(CHAR_1 == CHAR_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_EQUAL_CHAR
    
    SUBROUTINE ASSERT_ALMOST_EQUAL_INT(INT_1, INT_2, REL_TOL)
        INTEGER, INTENT(IN) :: INT_1, INT_2
        REAL(8), OPTIONAL :: REL_TOL

        REAL(8) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1D-9
        ENDIF

        PASSES = .FALSE.

        TOTAL = TOTAL + 1

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ELSE
            PASSES = ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            PASSED = PASSED+1
        ENDIF
    END SUBROUTINE ASSERT_ALMOST_EQUAL_INT

    SUBROUTINE ASSERT_ALMOST_EQUAL_INT_2BYTE(INT_1, INT_2, REL_TOL)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2
        REAL(8), OPTIONAL :: REL_TOL

        REAL(8) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1D-9
        ENDIF

        PASSES = .FALSE.

        TOTAL = TOTAL + 1

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ELSE
            PASSES = ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            PASSED = PASSED+1
        ENDIF
    END SUBROUTINE ASSERT_ALMOST_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_ALMOST_EQUAL_REAL_8BYTE(REAL_1, REAL_2, REL_TOL)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2
        REAL(8), OPTIONAL :: REL_TOL

        REAL(8) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1D-9
        ENDIF

        PASSES = .FALSE.

        TOTAL = TOTAL + 1

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(REAL_1-REAL_2)/REAL_1 <= TOLERANCE
        ELSE
            PASSES = ABS(REAL_1-REAL_2)/REAL_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            PASSED = PASSED+1
        ENDIF
    END SUBROUTINE ASSERT_ALMOST_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_ALMOST_EQUAL_REAL_4BYTE(REAL_1, REAL_2, REL_TOL)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2
        REAL(4), OPTIONAL :: REL_TOL

        REAL(4) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1E-9
        ENDIF

        PASSES = .FALSE.

        TOTAL = TOTAL + 1

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(REAL_1-REAL_2)/REAL_1 <= TOLERANCE
        ELSE
            PASSES = ABS(REAL_1-REAL_2)/REAL_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            PASSED = PASSED+1
        ENDIF
    END SUBROUTINE ASSERT_ALMOST_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_TRUE(STATEMENT)
        LOGICAL, INTENT(IN) :: STATEMENT

        TOTAL = TOTAL + 1

        IF(STATEMENT) THEN
            PASSED = PASSED + 1
        ENDIF

    END SUBROUTINE ASSERT_TRUE

    SUBROUTINE ASSERT_FALSE(STATEMENT)
        LOGICAL, INTENT(IN) :: STATEMENT

        TOTAL = TOTAL + 1

        IF(.NOT. STATEMENT) THEN
            PASSED = PASSED + 1
        ENDIF

    END SUBROUTINE ASSERT_FALSE

    SUBROUTINE ASSERT_NOT_EQUAL_INT(INT_1, INT_2)
        INTEGER, INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 /= INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_NOT_EQUAL_INT

    SUBROUTINE ASSERT_NOT_EQUAL_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 /= INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_NOT_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 /= REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_NOT_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_LOGICAL(BOOL_1, BOOL_2)
        LOGICAL, INTENT(IN) :: BOOL_1, BOOL_2
        
        TOTAL = TOTAL+1

        IF(BOOL_1 .NEQV. BOOL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_NOT_EQUAL_LOGICAL

    SUBROUTINE ASSERT_NOT_EQUAL_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 /= REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_NOT_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_CHAR(CHAR_1, CHAR_2)
        CHARACTER, INTENT(IN) :: CHAR_1, CHAR_2

        IF(CHAR_1 /= CHAR_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_NOT_EQUAL_CHAR

    SUBROUTINE ASSERT_NOT_EQUAL_COMPLEX(COMP_1, COMP_2)
        COMPLEX, INTENT(IN) :: COMP_1, COMP_2

        IF(COMP_1 /= COMP_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_NOT_EQUAL_COMPLEX

    SUBROUTINE ASSERT_GREATER_THAN_INT(INT_1, INT_2)
        INTEGER, INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 > INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_GREATER_THAN_INT

    SUBROUTINE ASSERT_GREATER_THAN_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 > INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_GREATER_THAN_INT_2BYTE

    SUBROUTINE ASSERT_GREATER_THAN_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 > REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_GREATER_THAN_REAL_4BYTE

    SUBROUTINE ASSERT_GREATER_THAN_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 > REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_GREATER_THAN_REAL_8BYTE

    SUBROUTINE ASSERT_LESS_THAN_INT(INT_1, INT_2)
        INTEGER, INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 < INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_LESS_THAN_INT

    SUBROUTINE ASSERT_LESS_THAN_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 < INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_LESS_THAN_INT_2BYTE

    SUBROUTINE ASSERT_LESS_THAN_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 < REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_LESS_THAN_REAL_8BYTE

    SUBROUTINE ASSERT_LESS_THAN_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 < REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_LESS_THAN_REAL_4BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT(INT_1, INT_2)
        INTEGER, INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 >= INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 >= INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_REAL_8BYTE(INT_1, INT_2)
        REAL(8), INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 >= INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_REAL_4BYTE(INT_1, INT_2)
        REAL(4), INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 >= INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT(INT_1, INT_2)
        INTEGER, INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 <= INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      
        TOTAL = TOTAL+1

        IF(INT_1 <= INT_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 <= REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2
        
        TOTAL = TOTAL+1

        IF(REAL_1 <= REAL_2) THEN
            PASSED = PASSED+1
        END IF   
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_IS_REAL_REAL_4BYTE(REAL_VAR)
        REAL(4), INTENT(IN) :: REAL_VAR

        PASSED = PASSED + 1
        TOTAL  = TOTAL + 1
    END SUBROUTINE ASSERT_IS_REAL_REAL_4BYTE

    SUBROUTINE ASSERT_IS_REAL_REAL_8BYTE(REAL_VAR)
        REAL(8), INTENT(IN) :: REAL_VAR

        PASSED = PASSED + 1
        TOTAL  = TOTAL + 1
    END SUBROUTINE ASSERT_IS_REAL_REAL_8BYTE

    SUBROUTINE ASSERT_IS_REAL_INT(INT_VAR)
        INTEGER, INTENT(IN) :: INT_VAR
        TOTAL  = TOTAL + 1
    END SUBROUTINE ASSERT_IS_REAL_INT

    SUBROUTINE ASSERT_IS_REAL_INT_2BYTE(INT_VAR)
        INTEGER(2), INTENT(IN) :: INT_VAR
        TOTAL  = TOTAL + 1
    END SUBROUTINE ASSERT_IS_REAL_INT_2BYTE

    SUBROUTINE ASSERT_IS_REAL_CHAR(CHAR_VAR)
        CHARACTER(*), INTENT(IN) :: CHAR_VAR
        TOTAL  = TOTAL + 1
    END SUBROUTINE ASSERT_IS_REAL_CHAR

    SUBROUTINE ASSERT_IS_REAL_BOOL(BOOL_VAR)
        LOGICAL, INTENT(IN) :: BOOL_VAR
        TOTAL  = TOTAL + 1
    END SUBROUTINE ASSERT_IS_REAL_BOOL

    SUBROUTINE ASSERT_IS_REAL_COMPLEX(COMP_VAR)
        COMPLEX, INTENT(IN) :: COMP_VAR
        TOTAL = TOTAL + 1
    END SUBROUTINE ASSERT_IS_REAL_COMPLEX
    
END MODULE